<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Antigravity Transaction Switch &mdash; Case Study &mdash; Nirav Ramidi</title>
    <meta name="description"
        content="Distributed transaction switch with RabbitMQ, FastAPI, and real-time dashboard. At-least-once delivery, auto-failover, and SRE observability." />

    <!-- Styles (kept separate) -->
    <link rel="stylesheet" href="../../assets/css/main.css" />
    <link rel="icon" href="../../assets/img/favicon.png" />
</head>

<body>
    <a class="skip-link" href="#content">Skip to content</a>

    <!-- Header / Nav -->
    <header class="site-header" role="banner">
        <div class="container header-inner">
            <a class="brand" href="../../" aria-label="Nirav Ramidi &mdash; home">
                <span class="brand__mark" aria-hidden="true">NR</span>
                <span class="brand__text">Nirav Ramidi</span>
            </a>

            <nav class="site-nav" aria-label="Primary">
                <ul class="nav-list">
                    <li><a href="../../">Home</a></li>
                    <li><a href="../../experience.html">Experience</a></li>
                    <li><a href="../" aria-current="page">Projects</a></li>
                    <li><a href="../../writing/">Writing</a></li>
                    <li><a href="../../education/">Education</a></li>
                    <li><a href="../../about.html">About</a></li>
                    <li class="hide-on-mobile"><a href="../../resume/" class="btn btn--ghost">Resume</a></li>
                </ul>
            </nav>

            <div class="header-actions">
                <div class="nav-icons">
                    <a href="https://github.com/Nirav01" target="_blank" rel="noopener" aria-label="GitHub">GitHub</a>
                    <a href="https://www.linkedin.com/in/nirav-ramidi/" target="_blank" rel="noopener"
                        aria-label="LinkedIn">LinkedIn</a>
                </div>

                <a href="../../resume/Nirav_Ramidi_CV.pdf" class="btn btn--primary show-on-mobile">Download CV</a>
            </div>
        </div>
    </header>

    <main id="content" class="site-main" role="main">
        <!-- Breadcrumbs -->
        <nav class="breadcrumbs container" aria-label="Breadcrumb">
            <ol>
                <li><a href="../../">Home</a></li>
                <li><a href="../">Projects</a></li>
                <li><a href="../">Cloud / SRE</a></li>
                <li><span aria-current="page">Antigravity Transaction Switch</span></li>
            </ol>
        </nav>

        <!-- Hero -->
        <section class="case-hero section">
            <div class="container case-hero__inner">
                <div class="case-hero__copy">
                    <h1>Antigravity Transaction Switch</h1>
                    <p class="lead">
                        Built a distributed, message-queue-based “transaction switch” that routes synthetic
                        payment-like events (“gravity particles”) across a pool of worker nodes with
                        at-least-once delivery, automatic failover, and a live WebSocket dashboard.
                    </p>
                    <ul class="metrics">
                        <li class="chip">FastAPI + WebSockets</li>
                        <li class="chip">RabbitMQ</li>
                        <li class="chip">Redis</li>
                        <li class="chip">Docker Compose</li>
                    </ul>
                </div>
                <figure class="case-hero__media">
                    <img src="../../assets/img/case-studies/real-time-switch-hero.png"
                        alt="Architecture diagram showing clients, API gateway, RabbitMQ, workers, and dashboard"
                        loading="lazy" />
                </figure>
            </div>
        </section>

        <!-- Meta + Body -->
        <section class="case-layout section">
            <div class="container grid case-grid">

                <aside class="case-meta card">
                    <h2 class="visually-hidden">Project info</h2>
                    <dl class="meta-list">
                        <dt>Type</dt>
                        <dd>Distributed systems &middot; Cloud / SRE</dd>
                        <dt>Role</dt>
                        <dd>Solo developer</dd>
                        <dt>Focus</dt>
                        <dd>Message queues, Fault tolerance, Observability</dd>
                        <dt>Stack</dt>
                        <dd>Python, FastAPI, RabbitMQ, Redis, Docker Compose, WebSockets, Chart.js, Locust</dd>
                        <dt>Links</dt>
                        <dd>
                            <ul class="bare">
                                <li><a href="../" aria-label="Back to projects">Back to Projects</a></li>
                                <li><a href="../../experience.html">Related experience</a></li>
                            </ul>
                        </dd>
                    </dl>
                </aside>

                <article class="case-body">
                    <!-- Context -->
                    <section class="case-section" id="context">
                        <h2>Problem &amp; Goals</h2>
                        <p>
                            Real payment switches sit between front-ends (ATMs, POS, mobile apps) and multiple
                            back-end processors. They need to route transactions in real time, tolerate node
                            failures, and provide strong delivery guarantees while remaining observable and
                            horizontally scalable.
                        </p>
                        <p>
                            This project recreates a simplified version of that environment to demonstrate core
                            distributed-systems concepts in a concrete way:
                        </p>
                        <ul>
                            <li>Model a mission-critical “transaction switch” using modern cloud primitives.</li>
                            <li>Demonstrate at-least-once delivery and graceful failure handling with a message broker.
                            </li>
                            <li>Show how to scale out stateless workers without changing the API contract.</li>
                            <li>Expose health and performance via a real-time dashboard suitable for SRE-style
                                monitoring.</li>
                        </ul>

                        <h3>Comparison to Real Payment Switches</h3>
                        <div class="table-wrapper">
                            <table>
                                <thead>
                                    <tr>
                                        <th>Feature</th>
                                        <th>Antigravity Switch</th>
                                        <th>BASE24 / XPNET</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><strong>Routing</strong></td>
                                        <td>RabbitMQ queues</td>
                                        <td>ISO8583 routers</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Failover</strong></td>
                                        <td>ACK/NACK + requeue</td>
                                        <td>Hot standby nodes</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Monitoring</strong></td>
                                        <td>WebSocket + Redis</td>
                                        <td>SNMP / Proprietary</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Scalability</strong></td>
                                        <td>Horizontal (add containers)</td>
                                        <td>Vertical + Clustering</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </section>

                    <!-- Architecture -->
                    <section class="case-section" id="architecture">
                        <h2>Architecture</h2>
                        <p>The system runs as a small cluster under Docker Compose:</p>
                        <div class="grid cards">
                            <article class="card">
                                <header class="card__header">
                                    <h3>API Gateway</h3>
                                </header>
                                <p class="card__body">FastAPI app that receives "gravity particles" (REST), exposes
                                    health checks, and streams telemetry via WebSockets.</p>
                            </article>
                            <article class="card">
                                <header class="card__header">
                                    <h3>RabbitMQ Broker</h3>
                                </header>
                                <p class="card__body">Central durable queue providing at-least-once delivery semantics
                                    via manual acknowledgements.</p>
                            </article>
                            <article class="card">
                                <header class="card__header">
                                    <h3>Worker Nodes</h3>
                                </header>
                                <p class="card__body">Stateless <code>switch-node</code> consumers that pull messages,
                                    simulate logic, and update metrics.</p>
                            </article>
                            <article class="card">
                                <header class="card__header">
                                    <h3>Redis &amp; Dashboard</h3>
                                </header>
                                <p class="card__body">Redis stores ephemeral metrics (throughput, heartbeats). The
                                    dashboard visualises this state in real-time.</p>
                            </article>
                        </div>
                    </section>

                    <!-- Message Flow -->
                    <section class="case-section" id="flow">
                        <h2>Message Flow</h2>
                        <ol>
                            <li>Client sends <code>POST /send</code> with payload.</li>
                            <li>API Gateway validates request and publishes to RabbitMQ.</li>
                            <li>RabbitMQ routes message to an available worker node (Round-robin).</li>
                            <li>Worker processes the "gravity particle" (transaction).</li>
                            <li>Worker sends <strong>ACK</strong> on success or <strong>NACK</strong> on failure.</li>
                            <li>If NACK'd (or timeout), RabbitMQ requeues to another node.</li>
                            <li>Worker updates Redis with throughput and status metrics.</li>
                            <li>Dashboard pulls metrics via WebSocket for real-time visualization.</li>
                        </ol>
                    </section>

                    <!-- Fault Tolerance -->
                    <section class="case-section" id="fault-tolerance">
                        <h2>Fault Tolerance &amp; Scaling</h2>
                        <h3>1. Message Persistence</h3>
                        <ul>
                            <li>Messages are marked as <strong>durable</strong>, surviving broker restarts.</li>
                            <li><strong>At-least-once delivery</strong> guarantees no transactions are lost.</li>
                        </ul>

                        <h3>2. Worker Failure Recovery</h3>
                        <ul>
                            <li>Workers send <strong>heartbeats every 5 seconds</strong> to Redis.</li>
                            <li>If a node stops heartbeating, it is marked <strong>OFFLINE</strong> on the dashboard.
                            </li>
                            <li>Unacknowledged messages held by a dying node are automatically requeued by RabbitMQ.
                            </li>
                        </ul>

                        <h3>3. Load Distribution</h3>
                        <ul>
                            <li>RabbitMQ uses <strong>Round-robin</strong> distribution.</li>
                            <li><strong>Prefetch count = 1</strong> ensures fair dispatch (workers don't hoard
                                messages).</li>
                        </ul>
                    </section>

                    <!-- Performance -->
                    <section class="case-section" id="performance">
                        <h2>Performance Characteristics</h2>
                        <ul class="metrics-grid">
                            <li>
                                <strong>Throughput</strong>
                                <span>1,000 - 1,500 TPS</span>
                            </li>
                            <li>
                                <strong>Latency</strong>
                                <span>~10ms (simulated)</span>
                            </li>
                            <li>
                                <strong>Availability</strong>
                                <span>99.9% (3+ nodes)</span>
                            </li>
                            <li>
                                <strong>Message Loss</strong>
                                <span>0%</span>
                            </li>
                        </ul>
                    </section>

                    <!-- Dashboard -->
                    <section class="case-section" id="observability">
                        <h2>Dashboard &amp; Observability</h2>
                        <p>
                            The dashboard is a small SPA served by FastAPI that presents an SRE-friendly view of the
                            switch.
                            It features real-time charts (Chart.js) for throughput and queue depth, a live list of
                            active nodes with status indicators, and controls to inject load.
                        </p>
                        <p>
                            Metrics are kept lightweight—simple Redis counters and gauges—showcasing how to decouple
                            telemetry from the hot path.
                        </p>
                    </section>

                    <!-- Deployment & Demo -->
                    <section class="case-section" id="demo">
                        <h2>Deployment &amp; Demo</h2>
                        <p>The system is containerized with Docker Compose. To run it:</p>
                        <pre><code>docker-compose up --build</code></pre>
                        <p>Access the dashboard at <code>http://localhost:8000</code>.</p>

                        <h3>Fault Tolerance Demo</h3>
                        <ol>
                            <li>Start the system and inject load (or use Locust).</li>
                            <li>Kill a worker node: <code>docker stop switch-node-1</code>.</li>
                            <li><strong>Observe:</strong> Traffic shifts to remaining nodes; no errors on client side.
                            </li>
                        </ol>
                    </section>

                    <!-- Interview Talking Points -->
                    <section class="case-section" id="talking-points">
                        <h2>Key Talking Points</h2>
                        <dl>
                            <dt>Why RabbitMQ?</dt>
                            <dd>Chosen for robust routing (Exchanges/Queues) and reliability, mirroring real payment
                                switch architectures (ISO8583).</dd>

                            <dt>How is it fault tolerant?</dt>
                            <dd>Manual <code>ack</code>/<code>nack</code>. If a node crashes before acking, the broker
                                requeues the message.</dd>

                            <dt>Scalability</dt>
                            <dd>Stateless workers allow infinite horizontal scaling by simply adding containers.</dd>

                            <dt>Observability</dt>
                            <dd>Decoupled metrics (Redis) prevent monitoring from blocking the critical transaction
                                path.</dd>
                        </dl>
                    </section>

                    <!-- Learnings -->
                    <section class="case-section" id="learnings">
                        <h2>What I learned</h2>
                        <ul class="checklist">
                            <li>How to use RabbitMQ for resilient, message-driven architectures.</li>
                            <li>The trade-offs between at-least-once delivery, idempotency, and complexity.</li>
                            <li>Separating API, processing, and observability into composable services.</li>
                            <li>Framing systems projects in SRE language: SLOs, availability, and failover.</li>
                        </ul>
                    </section>

                    <!-- Footer nav -->
                    <nav class="case-pager" aria-label="Case study pagination">
                        <a class="btn btn--ghost" href="../cloud-sre/library-analytics.html">&larr; Cloud-Native Library
                            Analytics</a>
                        <div class="spacer"></div>
                        <a class="btn btn--secondary" href="../hcai-viz/hcai-experiment.html">Next: HCAI Empirical Study
                            &rarr;</a>
                    </nav>
                </article>
            </div>
        </section>
    </main>

    <!-- Footer -->
    <footer class="site-footer" role="contentinfo">
        <div class="container footer-inner">
            <p>© <span id="year">2025</span> Nirav Ramidi</p>
            <ul class="footer-links">
                <li><a href="https://github.com/Nirav01" target="_blank" rel="noopener">GitHub</a></li>
                <li><a href="https://www.linkedin.com/in/nirav-ramidi/" target="_blank" rel="noopener">LinkedIn</a></li>
                <li><a href="../../resume/">Resume</a></li>
                <li><a href="../../contact.html">Contact</a></li>
            </ul>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="../../assets/js/main.js" defer></script>
</body>

</html>